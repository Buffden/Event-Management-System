import axios from 'axios';
import { logger } from '../utils/logger';
import { BookingConfirmedMessage } from '../types';

interface UserInfo {
  id: string;
  email: string;
  name: string;
}

interface EventInfo {
  id: string;
  name: string;
  description: string;
  bookingStartDate: string;
  bookingEndDate: string;
  venue: {
    name: string;
    address: string;
  };
}

class NotificationService {
  private readonly authServiceUrl: string;
  private readonly eventServiceUrl: string;
  private readonly notificationServiceUrl: string;

  constructor() {
    this.authServiceUrl = process.env.GATEWAY_URL ? 
      `${process.env.GATEWAY_URL}/api/auth` : 'http://ems-gateway/api/auth';
    this.eventServiceUrl = process.env.GATEWAY_URL ? 
      `${process.env.GATEWAY_URL}/api/event` : 'http://ems-gateway/api/event';
    this.notificationServiceUrl = process.env.GATEWAY_URL ? 
      `${process.env.GATEWAY_URL}/api/notification` : 'http://ems-gateway/api/notification';
  }

  /**
   * Initialize the notification service
   */
  async initialize(): Promise<void> {
    logger.info('Notification service initialized');
  }

  /**
   * Close the notification service
   */
  async close(): Promise<void> {
    logger.info('Notification service closed');
  }

  /**
   * Send booking confirmation email
   */
  async sendBookingConfirmationEmail(bookingMessage: BookingConfirmedMessage): Promise<void> {
    try {
      logger.info('Sending booking confirmation email', {
        bookingId: bookingMessage.bookingId,
        userId: bookingMessage.userId,
        eventId: bookingMessage.eventId
      });

      // Fetch user and event data in parallel
      const [userInfo, eventInfo] = await Promise.all([
        this.getUserInfo(bookingMessage.userId),
        this.getEventInfo(bookingMessage.eventId)
      ]);

      if (!userInfo || !eventInfo) {
        logger.error('Failed to fetch user or event info for booking confirmation email', new Error('Missing user or event info'), {
          bookingId: bookingMessage.bookingId,
          userId: bookingMessage.userId,
          eventId: bookingMessage.eventId,
          hasUserInfo: !!userInfo,
          hasEventInfo: !!eventInfo
        });
        return;
      }

      // Create notification message
      const notificationMessage = {
        type: 'BOOKING_CONFIRMED_NOTIFICATION',
        message: {
          to: userInfo.email,
          subject: '', // Will be generated by template service
          body: '', // Will be generated by template service
          attendeeName: userInfo.name,
          eventName: eventInfo.name,
          eventDate: eventInfo.bookingStartDate,
          venueName: eventInfo.venue.name,
          bookingId: bookingMessage.bookingId,
          eventId: bookingMessage.eventId
        }
      };

      // Send to notification service
      await this.sendToNotificationService(notificationMessage);

      logger.info('Booking confirmation email sent successfully', {
        bookingId: bookingMessage.bookingId,
        userEmail: userInfo.email,
        eventName: eventInfo.name
      });

    } catch (error) {
      logger.error('Failed to send booking confirmation email', error as Error, {
        bookingId: bookingMessage.bookingId,
        userId: bookingMessage.userId,
        eventId: bookingMessage.eventId
      });
      // Don't throw error - email failure shouldn't break the booking process
    }
  }

  /**
   * Get user information from auth service
   */
  private async getUserInfo(userId: string): Promise<UserInfo | null> {
    try {
      const response = await axios.get(`${this.authServiceUrl}/internal/users/${userId}`, {
        timeout: 5000,
        headers: {
          'Content-Type': 'application/json',
          'x-internal-service': 'event-service'
        }
      });

      if (response.status === 200 && response.data.valid) {
        return {
          id: response.data.user.id,
          email: response.data.user.email,
          name: response.data.user.name
        };
      }
      return null;
    } catch (error) {
      logger.warn('Failed to fetch user info', { userId, error: (error as Error).message });
      return null;
    }
  }

  /**
   * Get event information from event service
   */
  private async getEventInfo(eventId: string): Promise<EventInfo | null> {
    try {
      const response = await axios.get(`${this.eventServiceUrl}/events/${eventId}`, {
        timeout: 5000,
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (response.status === 200 && response.data.success) {
        const eventData = response.data.data;
        return {
          id: eventData.id,
          name: eventData.name,
          description: eventData.description,
          bookingStartDate: eventData.bookingStartDate,
          bookingEndDate: eventData.bookingEndDate,
          venue: {
            name: eventData.venue?.name || 'Unknown Venue',
            address: eventData.venue?.address || 'Unknown Address'
          }
        };
      }
      return null;
    } catch (error) {
      logger.warn('Failed to fetch event info', { eventId, error: (error as Error).message });
      return null;
    }
  }

  /**
   * Send notification message to notification service
   */
  private async sendToNotificationService(notificationMessage: any): Promise<void> {
    try {
      // For now, we'll use RabbitMQ directly to send to notification.email queue
      // This is a temporary solution - in a real system, you might want to use HTTP API
      
      const amqp = require('amqplib');
      const rabbitmqUrl = process.env.RABBITMQ_URL || 'amqp://guest:guest@localhost:5672';
      
      const connection = await amqp.connect(rabbitmqUrl);
      const channel = await connection.createChannel();
      
      const queueName = 'notification.email';
      await channel.assertQueue(queueName, { durable: true });
      
      const messageBuffer = Buffer.from(JSON.stringify(notificationMessage));
      channel.sendToQueue(queueName, messageBuffer, { persistent: true });
      
      await channel.close();
      await connection.close();
      
      logger.info('Notification message sent to notification service', {
        type: notificationMessage.type,
        to: notificationMessage.message.to
      });
    } catch (error) {
      logger.error('Failed to send notification message to notification service', error as Error);
      throw error;
    }
  }
}

export const notificationService = new NotificationService();
