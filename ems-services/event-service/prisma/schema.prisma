// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client"
  output        = "../generated/prisma"
  binaryTargets = ["native", "linux-arm64-openssl-3.0.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
}

enum EventStatus {
  DRAFT // Speaker is creating the event, not visible to anyone else.
  PENDING_APPROVAL // Speaker has submitted the event for admin review.
  REJECTED // Admin has rejected the event; speaker can edit and resubmit.
  PUBLISHED // Approved and live. Visible to the public.
  CANCELLED // Event has been cancelled.
  COMPLETED // Event date has passed.
}

enum SessionSpeakerMaterialsStatus {
  REQUESTED
  UPLOADED
  ACKNOWLEDGED
}

// Model for physical venues where events can be held.
model Venue {
  id          Int    @id @default(autoincrement())
  name        String @unique
  address     String @db.Text
  capacity    Int
  openingTime String // Stored in "HH:mm" format (24-hour).
  closingTime String // Stored in "HH:mm" format (24-hour).

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  events Event[]

  @@map("venues")
}

// Model for events created by speakers and admins for speakers.
model Event {
  id             String      @id @default(cuid())
  name           String
  description    String      @db.Text
  category       String
  bannerImageUrl String?
  status         EventStatus @default(DRAFT)

  // field to store the reason for rejection from an admin.
  rejectionReason String? @db.Text

  // Foreign key to the User in the Auth Service (the event owner).
  speakerId String

  venueId Int
  venue   Venue @relation(fields: [venueId], references: [id])

  // The start and end time for the entire venue booking.
  bookingStartDate DateTime
  bookingEndDate   DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions Session[]

  @@index([speakerId])
  @@index([venueId])
  @@index([status]) // Add index on status for efficient querying of pending events.
  @@map("events")
}

model Session {
  id          String   @id @default(cuid())
  eventId     String   @map("event_id")
  title       String
  description String?  @db.Text
  startsAt    DateTime @map("starts_at")
  endsAt      DateTime @map("ends_at")
  stage       String?

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  event    Event            @relation(fields: [eventId], references: [id], onDelete: Cascade)
  speakers SessionSpeaker[]

  @@index([eventId, startsAt])
  @@map("sessions")
}

model SessionSpeaker {
  id                      String                        @id @default(cuid())
  sessionId               String                        @map("session_id")
  speakerId               String                        @map("speaker_id")
  materialsAssetId        String?                       @map("materials_asset_id")
  materialsStatus         SessionSpeakerMaterialsStatus @default(REQUESTED) @map("materials_status")
  speakerCheckinConfirmed Boolean                       @default(false) @map("speaker_checkin_confirmed")
  specialNotes            String?                       @map("special_notes") @db.Text

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, speakerId])
  @@index([speakerId])
  @@map("session_speakers")
}
