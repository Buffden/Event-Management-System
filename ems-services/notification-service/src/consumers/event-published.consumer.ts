// src/consumers/event-published.consumer.ts

import { connect, ChannelModel, Channel, ConsumeMessage } from 'amqplib';
import axios from 'axios';
import { MESSAGE_TYPE, EventPublishedNotification } from '../types/types';

interface EventPublishedMessage {
  eventId: string;
  speakerId: string;
  name: string;
  capacity: number;
  bookingStartDate: string;
  bookingEndDate: string;
}

export class EventPublishedConsumer {
  private connection: ChannelModel | null = null;
  private channel: Channel | null = null;
  private readonly rabbitmqUrl: string;
  private readonly exchangeName = 'event.exchange';
  private readonly queueName = 'notification.event.published';
  private readonly routingKey = 'event.published';
  private readonly notificationQueueName = 'notification.email';
  private readonly authServiceUrl: string;
  private readonly eventServiceUrl: string;

  constructor(rabbitmqUrl: string) {
    this.rabbitmqUrl = rabbitmqUrl;
    const gatewayUrl = process.env.GATEWAY_URL || 'http://ems-gateway';
    this.authServiceUrl = `${gatewayUrl}/api/auth`;
    this.eventServiceUrl = `${gatewayUrl}/api/event`;
  }

  public async start(): Promise<void> {
    try {
      console.log('üöÄ Starting Event Published Consumer...');
      this.connection = await connect(this.rabbitmqUrl);
      if (this.connection) {
        this.channel = await this.connection.createChannel();
      }

      if (this.channel) {
        // Assert exchange (should already exist from event service)
        await this.channel.assertExchange(this.exchangeName, 'topic', { durable: true });

        // Assert our queue
        await this.channel.assertQueue(this.queueName, { durable: true });

        // Bind queue to exchange with routing key
        await this.channel.bindQueue(this.queueName, this.exchangeName, this.routingKey);

        // Assert notification queue
        await this.channel.assertQueue(this.notificationQueueName, { durable: true });

        this.channel.prefetch(1);

        console.log(`üëÇ Worker listening for event published events on exchange "${this.exchangeName}" with routing key "${this.routingKey}"`);
        this.channel.consume(this.queueName, this.handleMessage.bind(this), { noAck: false });
      }
    } catch (error) {
      console.error('‚ùå Error starting event published consumer:', error);
      setTimeout(() => {
        this.start().catch(err => console.error('‚ùå Retry failed:', err));
      }, 5000);
    }
  }

  private async handleMessage(msg: ConsumeMessage | null) {
    if (!msg || !this.channel) return;

    try {
      const eventData: EventPublishedMessage = JSON.parse(msg.content.toString());
      console.log('üìß Processing event published event:', eventData);

      // Process the event published event
      await this.processEventPublishedEvent(eventData);

      // Acknowledge the message
      this.channel.ack(msg);
    } catch (error) {
      console.error('‚ùå Error processing event published event:', error);
      this.channel.nack(msg, false, false);
    }
  }

  private async processEventPublishedEvent(eventData: EventPublishedMessage) {
    try {
      // Fetch event details to get full information
      const eventInfo = await this.getEventInfo(eventData.eventId);
      if (!eventInfo) {
        console.error('‚ùå Failed to fetch event info for event published notifications');
        return;
      }

      // Get all active users with verified emails
      const allUsers = await this.getAllUsers();
      if (!allUsers || allUsers.length === 0) {
        console.log(`‚ÑπÔ∏è  No active users found to notify about new event ${eventData.eventId}`);
        return;
      }

      console.log(`üìß Sending new event notifications to ${allUsers.length} users`);

      // Send notification to each user
      for (const user of allUsers) {
        try {
          // Create event published notification
          const notification: EventPublishedNotification = {
            type: MESSAGE_TYPE.EVENT_PUBLISHED_NOTIFICATION,
            message: {
              to: user.email,
              subject: '', // Will be generated by email template service
              body: '',    // Will be generated by email template service
              attendeeName: user.name || user.email,
              eventName: eventInfo.name,
              eventDescription: eventInfo.description || '',
              eventDate: new Date(eventInfo.bookingStartDate).toLocaleDateString(),
              venueName: eventInfo.venue?.name || 'Unknown Venue',
              bookingStartDate: eventInfo.bookingStartDate,
              bookingEndDate: eventInfo.bookingEndDate,
              eventId: eventData.eventId
            }
          };

          // Send notification to email queue
          const messageBuffer = Buffer.from(JSON.stringify(notification));
          if (this.channel) {
            this.channel.sendToQueue(this.notificationQueueName, messageBuffer, { persistent: true });
          }

          console.log(`‚úÖ Event published notification queued for ${user.email}`);
        } catch (error) {
          console.error(`‚ùå Error sending notification to user ${user.id}:`, error);
          // Continue with other users even if one fails
        }
      }

      console.log(`‚úÖ Completed processing event published notifications for ${eventData.eventId}`);
    } catch (error) {
      console.error('‚ùå Error processing event published event:', error);
    }
  }

  private async getAllUsers(): Promise<Array<{ id: string; email: string; name?: string }> | null> {
    try {
      // Use admin/users endpoint with internal service header and high limit to get all users
      const response = await axios.get(`${this.authServiceUrl}/admin/users?limit=10000&status=ACTIVE`, {
        timeout: 10000,
        headers: {
          'Content-Type': 'application/json',
          'x-internal-service': 'notification-service'
        }
      });

      if (response.status === 200 && response.data.success) {
        // Map the response data to match expected format
        return response.data.data.map((user: any) => ({
          id: user.id,
          email: user.email,
          name: user.name
        }));
      }
      return null;
    } catch (error) {
      console.error('‚ùå Error fetching all users:', error);
      return null;
    }
  }

  private async getEventInfo(eventId: string): Promise<any | null> {
    try {
      const response = await axios.get(`${this.eventServiceUrl}/events/${eventId}`, {
        timeout: 5000,
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (response.status === 200 && response.data.success) {
        return response.data.data;
      }
      return null;
    } catch (error) {
      console.error('‚ùå Error fetching event info:', error);
      return null;
    }
  }

  public async stop(): Promise<void> {
    console.log('üîå Shutting down event published consumer...');
    try {
      if (this.channel) await this.channel.close();
      if (this.connection) await this.connection.close();
    } catch (error) {
      console.error('Error during event published consumer shutdown:', error);
    }
  }
}

