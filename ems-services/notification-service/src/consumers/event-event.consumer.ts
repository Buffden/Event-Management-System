// src/consumers/event-event.consumer.ts

import { connect, ChannelModel, Channel, ConsumeMessage } from 'amqplib';
import axios from 'axios';
import { MESSAGE_TYPE, EventCancelledNotification } from '../types/types';

interface EventCancelledMessage {
  eventId: string;
}

export class EventEventConsumer {
  private connection: ChannelModel | null = null;
  private channel: Channel | null = null;
  private readonly rabbitmqUrl: string;
  private readonly exchangeName = 'event.exchange';
  private readonly queueName = 'notification.event.events';
  private readonly routingKey = 'event.cancelled';
  private readonly notificationQueueName = 'notification.email';
  private readonly authServiceUrl: string;
  private readonly eventServiceUrl: string;
  private readonly bookingServiceUrl: string;

  constructor(rabbitmqUrl: string) {
    this.rabbitmqUrl = rabbitmqUrl;
    const gatewayUrl = process.env.GATEWAY_URL || 'http://ems-gateway';
    this.authServiceUrl = `${gatewayUrl}/api/auth`;
    this.eventServiceUrl = `${gatewayUrl}/api/event`;
    this.bookingServiceUrl = `${gatewayUrl}/api/booking`;
  }

  public async start(): Promise<void> {
    try {
      console.log('üöÄ Starting Event Event Consumer...');
      this.connection = await connect(this.rabbitmqUrl);
      if (this.connection) {
        this.channel = await this.connection.createChannel();
      }

      if (this.channel) {
        // Assert exchange (should already exist from event service)
        await this.channel.assertExchange(this.exchangeName, 'topic', { durable: true });

        // Assert our queue
        await this.channel.assertQueue(this.queueName, { durable: true });

        // Bind queue to exchange with routing key
        await this.channel.bindQueue(this.queueName, this.exchangeName, this.routingKey);

        // Assert notification queue
        await this.channel.assertQueue(this.notificationQueueName, { durable: true });

        this.channel.prefetch(1);

        console.log(`üëÇ Worker listening for event events on exchange "${this.exchangeName}" with routing key "${this.routingKey}"`);
        this.channel.consume(this.queueName, this.handleMessage.bind(this), { noAck: false });
      }
    } catch (error) {
      console.error('‚ùå Error starting event event consumer:', error);
      setTimeout(() => {
        this.start().catch(err => console.error('‚ùå Retry failed:', err));
      }, 5000);
    }
  }

  private async handleMessage(msg: ConsumeMessage | null) {
    if (!msg || !this.channel) return;

    try {
      const eventData = JSON.parse(msg.content.toString());
      console.log('üìß Processing event cancelled event:', eventData);

      // Process the event cancelled event
      await this.processEventCancelledEvent(eventData);

      // Acknowledge the message
      this.channel.ack(msg);
    } catch (error) {
      console.error('‚ùå Error processing event event:', error);
      this.channel.nack(msg, false, false);
    }
  }

  private async processEventCancelledEvent(eventData: EventCancelledMessage) {
    try {
      // Fetch event details
      const eventInfo = await this.getEventInfo(eventData.eventId);
      if (!eventInfo) {
        console.error('‚ùå Failed to fetch event info for event cancellation notifications');
        return;
      }

      // Get all confirmed bookings for this event
      const bookings = await this.getEventBookings(eventData.eventId);
      if (!bookings || bookings.length === 0) {
        console.log(`‚ÑπÔ∏è  No confirmed bookings found for cancelled event ${eventData.eventId}`);
        return;
      }

      console.log(`üìß Sending cancellation notifications to ${bookings.length} registered users`);

      // Send notification to each registered user
      for (const booking of bookings) {
        try {
          // Fetch user info
          const userInfo = await this.getUserInfo(booking.userId);
          if (!userInfo) {
            console.warn(`‚ö†Ô∏è  Failed to fetch user info for userId: ${booking.userId}`);
            continue;
          }

          // Create event cancelled notification
          const notification: EventCancelledNotification = {
            type: MESSAGE_TYPE.EVENT_CANCELLED_NOTIFICATION,
            message: {
              to: userInfo.email,
              subject: '', // Will be generated by email template service
              body: '',    // Will be generated by email template service
              attendeeName: userInfo.name || userInfo.email,
              eventName: eventInfo.name,
              eventDate: new Date(eventInfo.bookingStartDate).toLocaleDateString(),
              venueName: eventInfo.venue?.name || 'Unknown Venue',
              cancellationReason: undefined, // Can be added later if needed
              eventId: eventData.eventId
            }
          };

          // Send notification to email queue
          const messageBuffer = Buffer.from(JSON.stringify(notification));
          if (this.channel) {
            this.channel.sendToQueue(this.notificationQueueName, messageBuffer, { persistent: true });
          }

          console.log(`‚úÖ Event cancellation notification queued for ${userInfo.email}`);
        } catch (error) {
          console.error(`‚ùå Error sending notification to user ${booking.userId}:`, error);
          // Continue with other users even if one fails
        }
      }

      console.log(`‚úÖ Completed processing event cancellation notifications for ${eventData.eventId}`);
    } catch (error) {
      console.error('‚ùå Error processing event cancelled event:', error);
    }
  }

  private async getUserInfo(userId: string): Promise<{ email: string; name?: string } | null> {
    try {
      const response = await axios.get(`${this.authServiceUrl}/internal/users/${userId}`, {
        timeout: 5000,
        headers: {
          'Content-Type': 'application/json',
          'x-internal-service': 'notification-service'
        }
      });

      if (response.status === 200 && response.data.valid) {
        return {
          email: response.data.user.email,
          name: response.data.user.name
        };
      }
      return null;
    } catch (error) {
      console.error('‚ùå Error fetching user info:', error);
      return null;
    }
  }

  private async getEventInfo(eventId: string): Promise<any | null> {
    try {
      const response = await axios.get(`${this.eventServiceUrl}/events/${eventId}`, {
        timeout: 5000,
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (response.status === 200 && response.data.success) {
        return response.data.data;
      }
      return null;
    } catch (error) {
      console.error('‚ùå Error fetching event info:', error);
      return null;
    }
  }

  private async getEventBookings(eventId: string): Promise<Array<{ userId: string }> | null> {
    try {
      // Get all confirmed bookings for the event (handle pagination)
      let allBookings: Array<{ userId: string }> = [];
      let page = 1;
      const limit = 100; // Get 100 at a time
      let hasMore = true;

      while (hasMore) {
        const response = await axios.get(
          `${this.bookingServiceUrl}/internal/events/${eventId}/bookings?status=CONFIRMED&page=${page}&limit=${limit}`,
          {
            timeout: 10000,
            headers: {
              'Content-Type': 'application/json',
              'x-internal-service': 'notification-service'
            }
          }
        );

        if (response.status === 200 && response.data.success) {
          const data = response.data.data;
          const bookings = data.bookings.map((booking: any) => ({
            userId: booking.userId
          }));
          allBookings = allBookings.concat(bookings);

          // Check if there are more pages
          hasMore = page < data.totalPages;
          page++;
        } else {
          hasMore = false;
        }
      }

      return allBookings.length > 0 ? allBookings : null;
    } catch (error) {
      console.error('‚ùå Error fetching event bookings:', error);
      return null;
    }
  }

  public async stop(): Promise<void> {
    console.log('üîå Shutting down event event consumer...');
    try {
      if (this.channel) await this.channel.close();
      if (this.connection) await this.connection.close();
    } catch (error) {
      console.error('Error during event event consumer shutdown:', error);
    }
  }
}

