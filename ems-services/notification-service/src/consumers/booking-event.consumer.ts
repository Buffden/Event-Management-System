// src/consumers/booking-event.consumer.ts

import { connect, ChannelModel, Channel, ConsumeMessage } from 'amqplib';
import axios from 'axios';
import { MESSAGE_TYPE, BookingConfirmedNotification } from '../types/types';

interface BookingConfirmedMessage {
  bookingId: string;
  userId: string;
  eventId: string;
  createdAt: string;
}

export class BookingEventConsumer {
  private connection: ChannelModel | null = null;
  private channel: Channel | null = null;
  private readonly rabbitmqUrl: string;
  private readonly exchangeName = 'booking_events';
  private readonly queueName = 'notification.booking.events';
  private readonly routingKey = 'booking.confirmed';
  private readonly notificationQueueName = 'notification.email';
  private readonly authServiceUrl: string;
  private readonly eventServiceUrl: string;

  constructor(rabbitmqUrl: string) {
    this.rabbitmqUrl = rabbitmqUrl;
    this.authServiceUrl = process.env.GATEWAY_URL ? 
      `${process.env.GATEWAY_URL}/api/auth` : 'http://ems-gateway/api/auth';
    this.eventServiceUrl = process.env.GATEWAY_URL ? 
      `${process.env.GATEWAY_URL}/api/event` : 'http://ems-gateway/api/event';
  }

  public async start(): Promise<void> {
    try {
      console.log('üöÄ Starting Booking Event Consumer...');
      this.connection = await connect(this.rabbitmqUrl);
      this.channel = await this.connection.createChannel();

      if (this.channel) {
        // Assert exchange (should already exist from booking service)
        await this.channel.assertExchange(this.exchangeName, 'topic', { durable: true });
        
        // Assert our queue
        await this.channel.assertQueue(this.queueName, { durable: true });
        
        // Bind queue to exchange with routing key
        await this.channel.bindQueue(this.queueName, this.exchangeName, this.routingKey);
        
        // Assert notification queue
        await this.channel.assertQueue(this.notificationQueueName, { durable: true });

        this.channel.prefetch(1);

        console.log(`üëÇ Worker listening for booking events on exchange "${this.exchangeName}" with routing key "${this.routingKey}"`);
        this.channel.consume(this.queueName, this.handleMessage.bind(this), { noAck: false });
      }
    } catch (error) {
      console.error('‚ùå Error starting booking event consumer:', error);
      setTimeout(() => {
        this.start().catch(err => console.error('‚ùå Retry failed:', err));
      }, 5000);
    }
  }

  private async handleMessage(msg: ConsumeMessage | null) {
    if (!msg || !this.channel) return;

    try {
      const bookingData = JSON.parse(msg.content.toString());
      console.log('üìß Processing booking confirmed event:', bookingData);

      // Process the booking confirmed event directly
      await this.processBookingConfirmedEvent(bookingData);

      // Acknowledge the message
      this.channel.ack(msg);
    } catch (error) {
      console.error('‚ùå Error processing booking event:', error);
      this.channel.nack(msg, false, false);
    }
  }

  private async processBookingConfirmedEvent(bookingData: BookingConfirmedMessage) {
    try {
      // Fetch user and event details
      const [userInfo, eventInfo] = await Promise.all([
        this.getUserInfo(bookingData.userId),
        this.getEventInfo(bookingData.eventId)
      ]);

      if (!userInfo || !eventInfo) {
        console.error('‚ùå Failed to fetch user or event info for booking confirmation email');
        return;
      }

      // Create booking confirmation notification
      const notification: BookingConfirmedNotification = {
        type: MESSAGE_TYPE.BOOKING_CONFIRMED_NOTIFICATION,
        message: {
          to: userInfo.email,
          subject: '', // Will be generated by email template service
          body: '',    // Will be generated by email template service
          attendeeName: userInfo.name || userInfo.email,
          eventName: eventInfo.name,
          eventDate: new Date(eventInfo.bookingStartDate).toLocaleDateString(),
          venueName: eventInfo.venue?.name || 'Unknown Venue',
          bookingId: bookingData.bookingId,
          eventId: bookingData.eventId
        }
      };

      // Send notification to email queue
      const messageBuffer = Buffer.from(JSON.stringify(notification));
      if (this.channel) {
        this.channel.sendToQueue(this.notificationQueueName, messageBuffer, { persistent: true });
      }
      
      console.log(`‚úÖ Booking confirmation notification queued for ${userInfo.email}`);
    } catch (error) {
      console.error('‚ùå Error processing booking confirmed event:', error);
    }
  }

  private async getUserInfo(userId: string): Promise<{ email: string; name?: string } | null> {
    try {
      const response = await axios.get(`${this.authServiceUrl}/internal/users/${userId}`, {
        timeout: 5000,
        headers: {
          'Content-Type': 'application/json',
          'x-internal-service': 'notification-service'
        }
      });

      if (response.status === 200 && response.data.valid) {
        return {
          email: response.data.user.email,
          name: response.data.user.name
        };
      }
      return null;
    } catch (error) {
      console.error('‚ùå Error fetching user info:', error);
      return null;
    }
  }

  private async getEventInfo(eventId: string): Promise<any | null> {
    try {
      const response = await axios.get(`${this.eventServiceUrl}/events/${eventId}`, {
        timeout: 5000,
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (response.status === 200 && response.data.success) {
        return response.data.data;
      }
      return null;
    } catch (error) {
      console.error('‚ùå Error fetching event info:', error);
      return null;
    }
  }

  public async stop(): Promise<void> {
    console.log('üîå Shutting down booking event consumer...');
    try {
      if (this.channel) await this.channel.close();
      if (this.connection) await this.connection.close();
    } catch (error) {
      console.error('Error during booking event consumer shutdown:', error);
    }
  }
}
