// src/consumers/BookingEventConsumer.ts

import { connect, Channel, Connection, ConsumeMessage } from 'amqplib';
import axios from 'axios';
import { MESSAGE_TYPE, BookingConfirmedNotification } from '../types/types';

interface BookingConfirmedMessage {
  bookingId: string;
  userId: string;
  eventId: string;
  createdAt: string;
}

export class BookingEventConsumer {
  private connection: any = null;
  private channel: Channel | null = null;
  private readonly rabbitmqUrl: string;
  private readonly bookingEventQueueName = 'booking-service.event.queue';
  private readonly notificationQueueName = 'notification.email';
  private readonly authServiceUrl: string;
  private readonly eventServiceUrl: string;

  constructor(rabbitmqUrl: string) {
    this.rabbitmqUrl = rabbitmqUrl;
    this.authServiceUrl = process.env.GATEWAY_URL ? 
      `${process.env.GATEWAY_URL}/api/auth` : 'http://ems-gateway/api/auth';
    this.eventServiceUrl = process.env.GATEWAY_URL ? 
      `${process.env.GATEWAY_URL}/api/event` : 'http://ems-gateway/api/event';
  }

  public async start(): Promise<void> {
    try {
      console.log('üöÄ Starting Booking Event Consumer...');
      this.connection = await connect(this.rabbitmqUrl);
      this.channel = await this.connection.createChannel();

      // Assert both queues
      if (this.channel) {
        await this.channel.assertQueue(this.bookingEventQueueName, { durable: true });
        await this.channel.assertQueue(this.notificationQueueName, { durable: true });

        this.channel.prefetch(1);

        console.log(`üëÇ Worker listening for booking events on queue "${this.bookingEventQueueName}"`);
        this.channel.consume(this.bookingEventQueueName, this.handleMessage.bind(this), { noAck: false });
      }
    } catch (error) {
      console.error('‚ùå Error starting booking event consumer:', error);
      setTimeout(() => {
        this.start().catch(err => console.error('‚ùå Retry failed:', err));
      }, 5000);
    }
  }

  private async handleMessage(msg: ConsumeMessage | null) {
    if (!msg || !this.channel) return;

    try {
      const bookingEvent = JSON.parse(msg.content.toString());
      console.log('üìß Processing booking event:', bookingEvent);

      // Check if this is a booking confirmed event
      if (bookingEvent.type === 'booking.confirmed') {
        await this.processBookingConfirmedEvent(bookingEvent.data);
      }

      // Acknowledge the message
      this.channel.ack(msg);
    } catch (error) {
      console.error('‚ùå Error processing booking event:', error);
      this.channel.nack(msg, false, false);
    }
  }

  private async processBookingConfirmedEvent(bookingData: BookingConfirmedMessage) {
    try {
      // Fetch user and event details
      const [userInfo, eventInfo] = await Promise.all([
        this.getUserInfo(bookingData.userId),
        this.getEventInfo(bookingData.eventId)
      ]);

      if (!userInfo || !eventInfo) {
        console.error('‚ùå Failed to fetch user or event info for booking confirmation email');
        return;
      }

      // Create booking confirmation notification
      const notification: BookingConfirmedNotification = {
        type: MESSAGE_TYPE.BOOKING_CONFIRMED_NOTIFICATION,
        message: {
          to: userInfo.email,
          subject: '', // Will be generated by email template service
          body: '',    // Will be generated by email template service
          attendeeName: userInfo.name || userInfo.email,
          eventName: eventInfo.name,
          eventDate: new Date(eventInfo.bookingStartDate).toLocaleDateString(),
          venueName: eventInfo.venue?.name || 'Unknown Venue',
          bookingId: bookingData.bookingId,
          eventId: bookingData.eventId
        }
      };

      // Send notification to email queue
      const messageBuffer = Buffer.from(JSON.stringify(notification));
      if (this.channel) {
        this.channel.sendToQueue(this.notificationQueueName, messageBuffer, { persistent: true });
      }
      
      console.log(`‚úÖ Booking confirmation notification queued for ${userInfo.email}`);
    } catch (error) {
      console.error('‚ùå Error processing booking confirmed event:', error);
    }
  }

  private async getUserInfo(userId: string): Promise<{ email: string; name?: string } | null> {
    try {
      const response = await axios.get(`${this.authServiceUrl}/internal/users/${userId}`, {
        timeout: 5000,
        headers: {
          'Content-Type': 'application/json',
          'x-internal-service': 'notification-service'
        }
      });

      if (response.status === 200 && response.data.valid) {
        return {
          email: response.data.user.email,
          name: response.data.user.name
        };
      }
      return null;
    } catch (error) {
      console.error('‚ùå Error fetching user info:', error);
      return null;
    }
  }

  private async getEventInfo(eventId: string): Promise<any | null> {
    try {
      const response = await axios.get(`${this.eventServiceUrl}/events/${eventId}`, {
        timeout: 5000,
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (response.status === 200 && response.data.success) {
        return response.data.data;
      }
      return null;
    } catch (error) {
      console.error('‚ùå Error fetching event info:', error);
      return null;
    }
  }

  public async stop(): Promise<void> {
    console.log('üîå Shutting down booking event consumer...');
    try {
      if (this.channel) await this.channel.close();
      if (this.connection) await this.connection.close();
    } catch (error) {
      console.error('Error during booking event consumer shutdown:', error);
    }
  }
}
