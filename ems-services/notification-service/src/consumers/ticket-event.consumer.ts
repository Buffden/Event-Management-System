// src/consumers/ticket-event.consumer.ts

import { connect, ChannelModel, Channel, ConsumeMessage } from 'amqplib';
import axios from 'axios';
import * as QRCode from 'qrcode';
import { MESSAGE_TYPE, TicketGeneratedNotification } from '../types/types';

interface TicketGeneratedMessage {
  ticketId: string;
  userId: string;
  eventId: string;
  bookingId: string;
  qrCodeData: string;
  expiresAt: string;
  createdAt: string;
}

export class TicketEventConsumer {
  private connection: ChannelModel | null = null;
  private channel: Channel | null = null;
  private readonly rabbitmqUrl: string;
  private readonly exchangeName = 'booking_events';
  private readonly queueName = 'notification.ticket.events';
  private readonly routingKey = 'ticket.generated';
  private readonly notificationQueueName = 'notification.email';
  private readonly authServiceUrl: string;
  private readonly eventServiceUrl: string;

  constructor(rabbitmqUrl: string) {
    this.rabbitmqUrl = rabbitmqUrl;
    this.authServiceUrl = process.env.GATEWAY_URL ?
      `${process.env.GATEWAY_URL}/api/auth` : 'http://ems-gateway/api/auth';
    this.eventServiceUrl = process.env.GATEWAY_URL ?
      `${process.env.GATEWAY_URL}/api/event` : 'http://ems-gateway/api/event';
  }

  public async start(): Promise<void> {
    try {
      console.log('üöÄ Starting Ticket Event Consumer...');
      this.connection = await connect(this.rabbitmqUrl);
      if (this.connection) {
        this.channel = await this.connection.createChannel();
      }

      if (this.channel) {
        // Assert exchange (should already exist from booking service)
        await this.channel.assertExchange(this.exchangeName, 'topic', { durable: true });

        // Assert our queue
        await this.channel.assertQueue(this.queueName, { durable: true });

        // Bind queue to exchange with routing key
        await this.channel.bindQueue(this.queueName, this.exchangeName, this.routingKey);

        // Assert notification queue
        await this.channel.assertQueue(this.notificationQueueName, { durable: true });

        this.channel.prefetch(1);

        console.log(`üëÇ Worker listening for ticket events on exchange "${this.exchangeName}" with routing key "${this.routingKey}"`);
        this.channel.consume(this.queueName, this.handleMessage.bind(this), { noAck: false });
      }
    } catch (error) {
      console.error('‚ùå Error starting ticket event consumer:', error);
      setTimeout(() => {
        this.start().catch(err => console.error('‚ùå Retry failed:', err));
      }, 5000);
    }
  }

  private async handleMessage(msg: ConsumeMessage | null) {
    if (!msg || !this.channel) return;

    try {
      const ticketData = JSON.parse(msg.content.toString());
      console.log('üé´ Processing ticket generated event:', ticketData);

      // Process the ticket generated event directly
      await this.processTicketGeneratedEvent(ticketData);

      // Acknowledge the message
      this.channel.ack(msg);
    } catch (error) {
      console.error('‚ùå Error processing ticket event:', error);
      this.channel.nack(msg, false, false);
    }
  }

  private async processTicketGeneratedEvent(ticketData: TicketGeneratedMessage) {
    try {
      // Fetch user and event details
      const [userInfo, eventInfo] = await Promise.all([
        this.getUserInfo(ticketData.userId),
        this.getEventInfo(ticketData.eventId)
      ]);

      if (!userInfo || !eventInfo) {
        console.error('‚ùå Failed to fetch user or event info for ticket email');
        return;
      }

      // Generate QR code image from text data
      let qrCodeImageBase64: string;
      try {
        // Generate QR code as PNG buffer and convert to base64
        const qrCodeBuffer = await QRCode.toBuffer(ticketData.qrCodeData, {
          type: 'png',
          width: 200,
          margin: 2,
          errorCorrectionLevel: 'M'
        });
        qrCodeImageBase64 = qrCodeBuffer.toString('base64');
      } catch (qrError) {
        console.error('‚ùå Failed to generate QR code image:', qrError);
        // Use empty string if QR code generation fails (email will still be sent)
        qrCodeImageBase64 = '';
      }

      // Generate ticket download URL (if you have a frontend route for viewing tickets)
      const clientUrl = process.env.CLIENT_URL || 'http://localhost';
      const ticketDownloadUrl = `${clientUrl}/dashboard/attendee/tickets/${ticketData.ticketId}`;

      // Create ticket notification
      const notification: TicketGeneratedNotification = {
        type: MESSAGE_TYPE.TICKET_GENERATED_NOTIFICATION,
        message: {
          to: userInfo.email,
          subject: '', // Will be generated by email template service
          body: '',    // Will be generated by email template service
          attendeeName: userInfo.name || userInfo.email,
          eventName: eventInfo.name,
          eventDate: new Date(eventInfo.bookingStartDate).toLocaleDateString(),
          venueName: eventInfo.venue?.name || 'Unknown Venue',
          ticketId: ticketData.ticketId,
          bookingId: ticketData.bookingId,
          eventId: ticketData.eventId,
          qrCodeData: qrCodeImageBase64,
          expiresAt: ticketData.expiresAt,
          ticketDownloadUrl: ticketDownloadUrl
        }
      };

      // Send notification to email queue
      const messageBuffer = Buffer.from(JSON.stringify(notification));
      if (this.channel) {
        this.channel.sendToQueue(this.notificationQueueName, messageBuffer, { persistent: true });
      }

      console.log(`‚úÖ Ticket notification queued for ${userInfo.email}`);
    } catch (error) {
      console.error('‚ùå Error processing ticket generated event:', error);
    }
  }

  private async getUserInfo(userId: string): Promise<{ email: string; name?: string } | null> {
    try {
      const response = await axios.get(`${this.authServiceUrl}/internal/users/${userId}`, {
        timeout: 5000,
        headers: {
          'Content-Type': 'application/json',
          'x-internal-service': 'notification-service'
        }
      });

      if (response.status === 200 && response.data.valid) {
        return {
          email: response.data.user.email,
          name: response.data.user.name
        };
      }
      return null;
    } catch (error) {
      console.error('‚ùå Error fetching user info:', error);
      return null;
    }
  }

  private async getEventInfo(eventId: string): Promise<any | null> {
    try {
      const response = await axios.get(`${this.eventServiceUrl}/events/${eventId}`, {
        timeout: 5000,
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (response.status === 200 && response.data.success) {
        return response.data.data;
      }
      return null;
    } catch (error) {
      console.error('‚ùå Error fetching event info:', error);
      return null;
    }
  }

  public async stop(): Promise<void> {
    console.log('üîå Shutting down ticket event consumer...');
    try {
      if (this.channel) await this.channel.close();
      if (this.connection) await this.connection.close();
    } catch (error) {
      console.error('Error during ticket event consumer shutdown:', error);
    }
  }
}

